---
layout  : post
title   : Linux에서 Link에 대해.
date    : 2019-05-16 21:57:03 +0900
updated : 2019-05-16 22:16:03 +0900
tags    : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

# 링크란?
젤다가 주인공인 게임의 이름..(혼돈)이 아니고 바로가기 같은 개념이다.
특정 폴더나 파일을 복사하지 않고 해당 위치에 있는 것 처럼 사용할 수 있다.

# 링크의 종류
링크에는 심볼릭링크와 하드링크가 있다.
심볼릭링크는 완전히 바로가기와 똑같이 동작하고, 하드링크는 거의 카피처럼 동작한다.

심볼링링크는 포인터, 하드링크는 스마트 포인터라고 생각하면 쉽게 이해 가능할 듯.
하드링크는 모든 링크파일을 지워야 원본에 접근이 불가하다. 실제로 레퍼런스 카운트를 체크하는지
구현체를 보고싶긴하다.

# 명령어와 동작
(Ubuntu 기준)

명령어는 `ln`이다. 기본적으로는 하드링크로 동작하며, `-s`옵션을 주변 심볼릭링크로 동작한다.

`ln [option] [target] [link_name]`

기본적으로 link_name 에 기존재하는 파일/디렉토리가 없어야 동작한다. 있으면 에러를 뱉어내는데, 이걸 무시하고 싶으면
`-f` 옵션을 주면된다.

# 주의할 점!
위 명령어 부분의 link_name에 디렉토리가 들어가면, 해당 디렉토리 안에 링크파일을 target의 이름으로 만들게 된다.
예를들어 `t`라는 파일이 있고, 이걸 `test_folder/`라는 폴더 안에 링크를 만들고 싶다고 할 때,
`ln -s t test_folder` 라고 하면, `test_folder/t`라는 심볼릭링크가 만들어지는 것이다.

여기서 실수가 일어난다.
만약, `target/` 이라는 폴더를 같은 폴더의 `sym/` 폴더로 심볼릭 링크를 만들고 싶을 때,
`ln -s target sym` 과 같이 하면 된다.

이걸 배포스크립트와 같은 곳이 집어넣고 항상성을 기대하며 재실행할 때, `-f`를 추가하여 재실행하게 되면,
`sym` 링크[폴더!!] 가 존재하여, 이 안에 생기게 된다.
그래서 `sym/target`이라는 링크가 만들어지고, 저 링크는 자신을 참조하는 무한 링크가 된다..

그래서, 올바른 방법은
1. `-f` 대신 `sym`을 지우고 다시 링크를 만든다.
2. `-T` 옵션을 주면, link name을 항상 파일로 인식한다. 그래서, `ln -sfT target sym`과 같이 실행하면 의도한대로 동작하게 된다.

오늘 이 부분때문에 삽질을 했기때문에 포스팅을 한 것 이기도 하다.
결론. Symlink만들때 디렉토리를 조심하자.
